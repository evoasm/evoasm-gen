/* vim: set filetype=c: */
/* AUTOGENERATED FILE, DO NOT EDIT */

#pragma once

#include "evoasm.h"
#include "evoasm-util.h"

#include <stdint.h>

<%= features.to_c %>

<%= inst_flags.to_c %>

<%= exceptions.to_c %>

<%= reg_types.to_c  %>

extern uint8_t evoasm_x64_reg_type_sizes_t[EVOASM_X64_N_REG_TYPES];

<%= reg_names.to_c %>

static inline evoasm_x64_reg_type_t
evoasm_x64_reg_type(evoasm_x64_reg_id_t reg) {
  switch(reg) {
<% Evoasm::Gen::X64::REGISTERS.each do |reg_type, regs| %>
  <% regs.each do |reg| %>
    case <%= reg_name_to_c reg %>: return <%= reg_type_to_c reg_type %>;
  <% end %>
<% end %>
    default: evoasm_assert_not_reached();
  }
}

<%= param_names.to_c %>

typedef enum {
<% insts.each do |inst| %>
  <%= inst_name_to_c inst %> = <%= inst.index %>,
<% end %>
  EVOASM_X64_N_INSTS = <%= insts.size %>,
} evoasm_x64_inst_id_t;

typedef struct {
  _EVOASM_ARCH_PARAMS_HEADER
  evoasm_arch_param_val_t vals[EVOASM_X64_N_PARAMS];
} evoasm_x64_params_t;

_Static_assert(EVOASM_X64_N_PARAMS <= EVOASM_ARCH_MAX_PARAMS, "Too much parameters. Redeclar EVOASM_ARCH_MAX_PARAMS and evoasm_arch_params_bitmap.");

typedef struct {
  evoasm_arch_t base;
  uint64_t features;
} evoasm_x64_t;

<%= operand_types.to_c %>

<%= bit_masks.to_c %>
#define <%= bit_mask_to_c 0..63 %> (<%= bit_mask_to_c 0..31 %> | <%= bit_mask_to_c 32..63 %>)
#define <%= bit_mask_to_c 0..127 %> (<%= bit_mask_to_c 0..63 %> | <%= bit_mask_to_c 64..127 %>)

typedef struct {
  unsigned acc_r: 1;
  unsigned acc_w: 1;
  unsigned acc_u: 1;
  unsigned acc_c: 1;
  unsigned implicit: 1;
  unsigned param_idx: 5;
  unsigned type: EVOASM_X64_OPERAND_TYPE_BITSIZE;
  unsigned size: EVOASM_OPERAND_SIZE_BITSIZE_WITH_N;
  unsigned reg_id: EVOASM_X64_REG_BITSIZE_WITH_N;
  unsigned reg_type: EVOASM_X64_REG_TYPE_BITSIZE_WITH_N;
  unsigned acc_w_mask: EVOASM_X64_BIT_MASK_BITSIZE;
} evoasm_x64_operand_t;

typedef bool (*evoasm_x64_inst_enc_func_t)(evoasm_x64_t *x64, evoasm_arch_param_val_t *param_vals, evoasm_bitmap_t *set_params);

typedef struct {
  EVOASM_INST_HEADER
  evoasm_x64_inst_enc_func_t enc_func;
  uint64_t features;
  evoasm_x64_operand_t *operands;
  uint8_t n_operands;
  uint32_t exceptions;
  uint32_t flags;
} evoasm_x64_inst_t;

#define EVOASM_X64_ENC(inst) \
  EVOASM_TRY(enc_failed, evoasm_x64_##inst, x64, params.vals, (evoasm_bitmap_t *) &params.set)

#define EVOASM_X64_SET(param, val) \
  evoasm_arch_params_set(params.vals, (evoasm_bitmap_t *) &params.set, param, val)

#define EVOASM_X64_UNSET(param) \
  evoasm_arch_params_unset(params.vals, (evoasm_bitmap_t *) &params.set, param)

typedef enum {
  EVOASM_X64_ABI_SYSV
} evoasm_x64_abi_t;

void
evoasm_x64_destroy(evoasm_x64_t *x64);

evoasm_success_t
evoasm_x64_init(evoasm_x64_t *x64);

evoasm_success_t
evoasm_x64_func_prolog(evoasm_x64_t *x64, evoasm_buf_t *buf, evoasm_x64_abi_t abi);

evoasm_success_t
evoasm_x64_func_epilog(evoasm_x64_t *x64, evoasm_buf_t *buf, evoasm_x64_abi_t abi);

extern const evoasm_x64_inst_t *<%= insts_var_name %>;

static inline const evoasm_x64_inst_t *
evoasm_x64_get_inst(unsigned index) {
  return &<%= insts_var_name %>[index];
}

static inline evoasm_success_t
evoasm_x64_inst_enc(const evoasm_x64_inst_t *inst, evoasm_x64_t *x64, evoasm_arch_param_val_t *param_vals, evoasm_bitmap_t *set_params) {
  return inst->enc_func(x64, param_vals, set_params);
}

static inline evoasm_success_t
evoasm_x64_enc(evoasm_x64_t *x64, evoasm_inst_id_t inst_id, evoasm_arch_param_val_t *param_vals, evoasm_bitmap_t *set_params) {
  const evoasm_x64_inst_t *inst = &<%= insts_var_name %>[inst_id];
  return evoasm_x64_inst_enc(inst, x64, param_vals, set_params);
}

<% insts.each do |inst| %>
<%= func_prototype_to_c(inst.name, static: false) %>;
<% end %>

