/* AUTOGENERATED FILE, DO NOT EDIT */

/*
 * Copyright (C) 2016 Julian Aron Prenner <jap@polyadic.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "evoasm-x64.h"

static const char *_evoasm_log_tag = "x64";

evoasm_success_t
evoasm_x64_get_features(uint64_t *features_) {
  evoasm_buf_t buf_;
  evoasm_buf_t *buf = &buf_;
  evoasm_x64_params_t params = {0};
  bool retval = true;
  uint64_t features = 0;

  uint32_t vals[<%= Evoasm::Gen::X64::CPUID.size %>][<%= Evoasm::Gen::X64::CPUID.max_by{|k, v| v.size}.size %>] = {0};

  evoasm_log_debug("Running CPUID...");

  EVOASM_TRY(alloc_failed, evoasm_buf_init, buf, EVOASM_BUF_TYPE_MMAP, 512);
  EVOASM_TRY(enc_failed, evoasm_x64_emit_func_prolog, EVOASM_X64_ABI_SYSV, buf);

<% remaining_flags = unit.features.symbols %>
<% io = StringIO.new %>
<% Evoasm::Gen::X64::CPUID.each_with_index do |((eax_val, ecx_val), out_regs), index0| %>

  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_A);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, <%= eax_val %>);
  EVOASM_X64_ENC(mov_r32_imm32);

  <% if ecx_val %>
  EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_C);
  EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, <%= ecx_val %>);
  EVOASM_X64_ENC(mov_r32_imm32);
  <% end %>

  EVOASM_X64_ENC(cpuid);

  <% out_regs.each.with_index do |(reg, flags), index1| %>

  {
    int64_t addr_imm;
    addr_imm = (int64_t)(uintptr_t) &vals[<%= index0 %>][<%= index1 %>];
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG0, EVOASM_X64_REG_DI);
    EVOASM_X64_SET(EVOASM_X64_PARAM_IMM0, addr_imm);
    EVOASM_X64_ENC(mov_r64_imm64);

    EVOASM_X64_SET(EVOASM_X64_PARAM_REG1, <%= unit.register_name_to_c reg %>);
    EVOASM_X64_SET(EVOASM_X64_PARAM_REG_BASE, EVOASM_X64_REG_DI);
    EVOASM_X64_ENC(mov_rm32_r32);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_ADDR_SIZE);
    EVOASM_X64_UNSET(EVOASM_X64_PARAM_REG_BASE);

    <% flags.each_with_index do |flag, bit_index| %>
      <% if remaining_flags.delete(flag) %>
        <% io.indent absolute: 1 do %>
          <% io.puts "if(vals[#{index0}][#{index1}] & (1ull << #{bit_index})) {" %>
          <% io.puts "  features |= (1ull << #{unit.feature_name_to_c flag});" %>
          <% io.puts %{  evoasm_log_info("Found support for #{flag.upcase}");} %>
          <% io.puts "} else {" %>
          <% io.puts %{  evoasm_log_info("Missing support for #{flag.upcase}");} %>
          <% io.puts "}" %>
        <% end %>
      <% end %>
    <% end %>
  }
  <% end%>
<% end %>

  EVOASM_TRY(enc_failed, evoasm_x64_emit_func_epilog, EVOASM_X64_ABI_SYSV, buf);

  /*evoasm_buf_dump(buf, stderr);*/

  EVOASM_TRY(enc_failed, evoasm_buf_protect, buf, EVOASM_MPROT_MODE_RX);
  evoasm_buf_exec(buf);

<%= io.string %>

  *features_ = features;

cleanup:
  EVOASM_TRY(destroy_failed, evoasm_buf_destroy, buf);
  return retval;
enc_failed:
  retval = false;
  goto cleanup;
destroy_failed:
  return false;
alloc_failed:
  return false;
}

